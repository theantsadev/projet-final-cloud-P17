package com.idp.service;

import com.idp.dto.*;
import com.idp.entity.User;
import com.idp.entity.UserSession;
import com.idp.repository.UserRepository;
import com.idp.repository.UserSessionRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.time.LocalDateTime;
import java.util.UUID;

@Service
@RequiredArgsConstructor
public class AuthService {

    private final UserRepository userRepository;
    private final UserSessionRepository sessionRepository;
    private final PasswordEncoder passwordEncoder;
    private final JwtService jwtService;
    private final SyncService syncService;

    @Value("${security.max.login.attempts:3}")
    private int maxLoginAttempts;

    @Value("${security.lockout.duration.minutes:30}")
    private int lockoutDurationMinutes;

    @Value("${security.session.duration.minutes:60}")
    private int sessionDurationMinutes;

    // INSCRIPTION
    // @Transactional
    // public AuthResponse register(RegisterRequest request) {
    //     if (userRepository.findByEmail(request.getEmail()).isPresent()) {
    //         throw new RuntimeException("Email d√©j√† utilis√©");
    //     }

    //     User user = new User();
    //     user.setId(UUID.randomUUID().toString());
    //     user.setEmail(request.getEmail());
    //     user.setPasswordHash(passwordEncoder.encode(request.getPassword()));
    //     user.setFullName(request.getFullName());
    //     user.setPhone(request.getPhone());

    //     User savedUser = userRepository.save(user);

    //     // Sync Firestore
    //     syncService.syncUserToFirestore(savedUser);

    //     // G√©n√©rer tokens
    //     String token = jwtService.generateToken(savedUser.getId());
    //     String refreshToken = jwtService.generateRefreshToken(savedUser.getId());

    //     return AuthResponse.builder()
    //             .token(token)
    //             .refreshToken(refreshToken)
    //             .user(savedUser)
    //             .build();
    // }
    // Dans votre AuthService.java, modifiez la m√©thode register :
    @Transactional
    public AuthResponse register(RegisterRequest request) {
        if (userRepository.findByEmail(request.getEmail()).isPresent()) {
            throw new RuntimeException("Email d√©j√† utilis√©");
        }

        User user = User.builder()
                .id(UUID.randomUUID().toString())
                .email(request.getEmail())
                .passwordHash(passwordEncoder.encode(request.getPassword()))
                .fullName(request.getFullName())
                .phone(request.getPhone())
                .firestoreId(UUID.randomUUID().toString()) // G√©n√©rer ID Firestore
                .syncStatus("PENDING") // Marquer comme √† synchroniser
                .build();

        User savedUser = userRepository.save(user);

        // üî• ICI - Synchroniser IMM√âDIATEMENT
        try {
            syncService.syncUserToFirestore(savedUser);
        } catch (Exception e) {
            log.warn("‚ö†Ô∏è  Sync imm√©diat √©chou√©, sera retent√© automatiquement: {}", e.getMessage());
            // On continue car la synchro automatique va retenter
        }

        // G√©n√©rer tokens
        String token = jwtService.generateToken(savedUser.getId());
        String refreshToken = jwtService.generateRefreshToken(savedUser.getId());

        return AuthResponse.builder()
                .token(token)
                .refreshToken(refreshToken)
                .user(savedUser)
                .build();
    }
    // CONNEXION
    @Transactional
    public AuthResponse login(LoginRequest request, String ipAddress, String userAgent) {
        String email = request.getEmail().toLowerCase();
        User user = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("Identifiants invalides"));

        // V√©rifier blocage
        if (user.getIsLocked() && user.getLastFailedLogin() != null) {
            LocalDateTime lockUntil = user.getLastFailedLogin().plusMinutes(lockoutDurationMinutes);
            if (LocalDateTime.now().isBefore(lockUntil)) {
                throw new RuntimeException("Compte bloqu√©. R√©essayez plus tard.");
            } else {
                user.setIsLocked(false);
                user.setFailedLoginAttempts(0);
            }
        }

        // V√©rifier mot de passe
        if (!passwordEncoder.matches(request.getPassword(), user.getPasswordHash())) {
            handleFailedLogin(user);
            throw new RuntimeException("Identifiants invalides");
        }

        // V√©rifier compte actif
        if (!user.getIsActive()) {
            throw new RuntimeException("Compte d√©sactiv√©");
        }

        // R√©initialiser tentatives
        user.setFailedLoginAttempts(0);
        user.setLastLogin(LocalDateTime.now());
        userRepository.save(user);

        // Cr√©er session
        String token = jwtService.generateToken(user.getId());
        String refreshToken = jwtService.generateRefreshToken(user.getId());

        createSession(user, token, refreshToken, ipAddress, userAgent);

        return AuthResponse.builder()
                .token(token)
                .refreshToken(refreshToken)
                .user(user)
                .build();
    }

    private void handleFailedLogin(User user) {
        int attempts = user.getFailedLoginAttempts() + 1;
        user.setFailedLoginAttempts(attempts);
        user.setLastFailedLogin(LocalDateTime.now());

        if (attempts >= maxLoginAttempts) {
            user.setIsLocked(true);
        }

        userRepository.save(user);
    }

    private void createSession(User user, String token, String refreshToken,
            String ipAddress, String userAgent) {
        UserSession session = new UserSession();
        session.setId(UUID.randomUUID().toString());
        session.setUser(user);
        session.setSessionToken(token);
        session.setRefreshToken(refreshToken);
        session.setIpAddress(ipAddress);
        session.setDeviceInfo(userAgent);
        session.setExpiresAt(LocalDateTime.now().plusMinutes(sessionDurationMinutes));

        sessionRepository.save(session);
    }

    // D√âBLOQUER COMPTE
    @Transactional
    public void unlockAccount(String email) {
        User user = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("Utilisateur non trouv√©"));

        user.setIsLocked(false);
        user.setFailedLoginAttempts(0);
        userRepository.save(user);

        syncService.syncUserToFirestore(user);
    }
    // Ajoute √† la fin de AuthService.java

    // D√âCONNEXION
    @Transactional
    public void logout(String jwtToken) {
        String userId = jwtService.extractUserId(jwtToken);

        // Invalider toutes les sessions de l'utilisateur
        sessionRepository.findByUserId(userId).forEach(session -> {
            session.setIsValid(false);
            sessionRepository.save(session);
        });
    }

    // MODIFIER PROFIL
    @Transactional
    public User updateProfile(String jwtToken, UpdateProfileRequest request) {
        String userId = jwtService.extractUserId(jwtToken);
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new RuntimeException("Utilisateur non trouv√©"));

        // Mettre √† jour les champs
        if (request.getFullName() != null) {
            user.setFullName(request.getFullName());
        }
        if (request.getPhone() != null) {
            user.setPhone(request.getPhone());
        }

        // Changer mot de passe si demand√©
        if (request.getCurrentPassword() != null && request.getNewPassword() != null) {
            if (!passwordEncoder.matches(request.getCurrentPassword(), user.getPasswordHash())) {
                throw new RuntimeException("Mot de passe actuel incorrect");
            }
            user.setPasswordHash(passwordEncoder.encode(request.getNewPassword()));
        }

        User updatedUser = userRepository.save(user);

        // Sync
        syncService.syncUserToFirestore(updatedUser);

        return updatedUser;
    }

    // MON PROFIL
    public User getProfile(String jwtToken) {
        String userId = jwtService.extractUserId(jwtToken);
        return userRepository.findById(userId)
                .orElseThrow(() -> new RuntimeException("Utilisateur non trouv√©"));
    }

    // RAFRA√éCHIR TOKEN
    public AuthResponse refreshToken(String refreshToken) {
        if (!jwtService.isTokenValid(refreshToken)) {
            throw new RuntimeException("Refresh token invalide");
        }

        String userId = jwtService.extractUserId(refreshToken);
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new RuntimeException("Utilisateur non trouv√©"));

        // G√©n√©rer nouveaux tokens
        String newToken = jwtService.generateToken(userId);
        String newRefreshToken = jwtService.generateRefreshToken(userId);

        return AuthResponse.builder()
                .token(newToken)
                .refreshToken(newRefreshToken)
                .user(user)
                .build();
    }
}